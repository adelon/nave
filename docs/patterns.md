# Patterns


Some examples of patterns.
Intended as a guide for the implementation.


### Adjectival patterns

#### Unary adjectival patterns

These are by far the easiest to handle and luckily also the most common.

When modifying nominals, these patterns typically attach at the front.
Thus `an even divisor of _`, `a positive upper bound for _`,
 `a measurable function`, `a simply connected space`, etc.

```
affine
analytic
associative
bounded
closed
compact
complete
completely additive
continuous
convergent
convex
differentiable
disjoint
√©tale
even
finite
finite-dimensional
finitely complete
finitely generated
free
invertible
linear
locally presentable
measurable
multiplicative
nilpotent
normal
odd
open
orthogonal
parallel
path-connected
piecewise linear
quasicoherent
reflexive
regular
self-adjoint
simply connected
smooth
sound
strongly locally compact
symmetric
T1 # (and all the others.. this should probably be formalized as a TEX macro)
torsion-free
transitive
triangular
trivial
unimodular
```

The exception are mainly adjectival patterns starting with `of`.
They attach at the back, thus `group of infinite order`,
`subset closed under complements`, `scheme of finite type`, etc.

```
of infinite order
of finite type
closed under complements
```

For each simple adjective we could derive a negated variant with a `non-` prefix.
The only problem is that there are cases where `non-` does indicate a negation but
means 'not necessarily' instead, e.g.: `noncommutative`.
The lack of a hyphen could indicate that this is a separately defined adjective
and not a derived adjective.


#### Collective unary adjectival patterns

```
(a,b,c are) cobordant
(a,b,c are) commensurable
(a,b,c are) linearly independent
(a,b,c are) unifiable
(a,b,c are) collinear
```

#### Binary adjectival patterns

The most common binary adjectival pattern is `<adjective> <preposition> _`.
Prepositions are a closed category,
so it is feasible to recognize the structure of these patterns.

When modifying nominals, patterns with prepositions attack on the right.
Thus `a scheme of finite type over _`, `a natural number equal to _`,
`an integer less than _`, etc.

```
_-accessible
_-equivariant
_-transfinite
continuous on _
divisible by _
equal to _
full in _
generated by _
greater than _
incident with _
isolated in _
less than _
meromorphic on _
nowhere dense in _
of finite type over _
of order _
represented by _
strictly greater than _
strictly less than _
```




### Nominal patterns

#### Nullary nominal patterns

```
manifolds[/s] with boundary
matri[x/ces]
natural number[/s]
surjection[/s]
œÉ-algebra[/s]
```

Structures:

```
group[/s]
monoid[/s]
ring[/s]
semigroup[/s]
toset[/s]
ultrafilter[/s]
vector space[/s]
```


#### Unary nominal patterns

ForTheL has some special derived forms for patterns using `of`.


```
_-adic number[/s]
divisor[/s] of _
extension[/s] of _
fixed point[/s] of _
local bas[is/es] at _
regular _-gon[/s]
sphere packing[/s] in _-space
upper bound[/s] for _
vector space[/s] over _
ùúî-accumulation point[/s] of _
subspace[/s] of _
uniformit[y/ies] on _
```


#### Binary nominal patterns

`-TH` stands for special case handling of `1st, 2nd, ... , n-th`.

```
-TH root[/s] of unity modulo -
homomorphism[/s] from _ to _
isomorphism[/s] from _ to _
principal _-bundle[/s] over _
principal _-connection[/s] on _
```

### Ternary nominal patterns

```
```


### Functional patterns

#### Nullary functional patterns (constants)

It seems like a plural for these patterns is unnecessary.

```
empty set
identity function
```

#### Unary functional patterns

```
_-ball[/s]
(the) conjugate transpose[/s] of _
(the) core[/s] of _
(the) expectation value[/s] of _
(the) free group[/s] generated by _
(the) height[/s] of _
(the) homotopy fibre[/s] of _
(the) homotopy group[/s] of _
(the) kernel[/s] of _
(the) length[/s] of _
(the) successor[/s] of _
(the) preimage[/s] of _
(the) square[/s] of _
```

#### Binary functional patterns

```
greatest common divisor of _ and _   # or should this be a collective pattern?
(the) commutator of _ and
(the) restriction of _ to _
(the) centralizer of _ in _
(the) complement of _ relative to _
```





### Verbal patterns

Verbal patterns can be detected by the lack of a copula in their definition.

#### Unary verbal patterns (intransitive verbs)

```
converge[s/]
ha[s/ve] a subobject classifier
ha[s/ve] finite limits
preserve[s/] colimits
```

#### Binary verbal patterns (transitive verbs)

```
admit[s/] an embedding in _
converge[s/] to _
divide[s/] _
dominate[s/] _
equals[s/] _
```

#### Ternary verbal patterns (ditransitive verbs)
